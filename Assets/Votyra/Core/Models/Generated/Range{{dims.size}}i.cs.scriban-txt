using System;

namespace Votyra.Core.Models
{
    /// <summary>
    ///     Max is exclusive
    /// </summary>
    {{dimSize = dims.size}}
    {{type = "Range" +dimSize +"i"}}
    {{areaType = "Area" +dimSize +"i"}}
    {{areaFloatType = "Area" +dimSize +"f"}}
    {{area1MoreFloatType = "Area" +(dimSize+1) +"f"}}

    
    {{vectorFloatType = "Vector" +dimSize +"f"}}
    {{vectorIntType = "Vector" +dimSize +"i"}}
    {{if dimSize != 1}}
        {{vectorFloatRealType=vectorFloatType}}
        {{vectorIntRealType=vectorIntType}}
    {{else}}
        {{vectorFloatRealType="float"}}
        {{vectorIntRealType="int"}}
    {{end}}
    {{func dimAccess}}{{if dimSize!=1}}{{$0}}.{{$1}}{{else}}{{$0}}{{end}}{{end}}
    
    {{vector1MoreFloatType = "Vector" +(dimSize+1) +"f"}}


    public partial struct {{type}} : IEquatable<{{type}}>
    {
        public static readonly {{vectorIntRealType}} MinValue = {{vectorIntType}}Utils.FromSame(int.MinValue / 2);
        public static readonly {{vectorIntRealType}} MaxValue = {{vectorIntType}}Utils.FromSame(int.MaxValue / 2);

        public static readonly {{type}} All = new {{type}}(MinValue, MaxValue);

        public static readonly {{type}} Zero = new {{type}}();

        public readonly {{vectorIntRealType}} Min;

        public readonly {{vectorIntRealType}} Max;

        public bool IsEmpty => Size == {{vectorIntType}}.Zero;

        private {{type}}({{vectorIntRealType}} min, {{vectorIntRealType}} max)
        {
            Min = {{vectorIntType}}Utils.Max(min, MinValue);
            Max = {{vectorIntType}}Utils.Min(max, MaxValue);
            if (Size.AnyNegative())
                throw new InvalidOperationException($"{nameof({{type}})} '{this}' cannot have a size be zero or negative!");
            if (Size.AnyZero())
                Max = Min;
        }

        public {{type}} ExtendBothDirections(int distance)
        {
            if (IsEmpty)
                return this;
            return FromMinAndMax(Min - distance, Max + distance);
        }

        public {{vectorIntRealType}} Size => Max - Min;

        public static {{type}} FromMinAndSize({{vectorIntRealType}} min, {{vectorIntRealType}} size)
        {
            if (size.AnyNegative())
                throw new InvalidOperationException($"When creating {nameof({{type}})} using min '{min}' and size '{size}', size cannot have a negative coordinate!");
            return new {{type}}(min, min + size);
        }

        public static {{type}} FromMinAndMax({{vectorIntRealType}} min, {{vectorIntRealType}} max) => new {{type}}(min, max);
        
        public static {{type}} FromCenterAndExtents({{vectorIntRealType}} center, {{vectorIntRealType}} extents)
        {
            if (extents.AnyNegative())
                throw new InvalidOperationException($"When creating {nameof({{type}})} from center '{center}' and extents '{extents}', extents cannot have a negative coordinate!");
            return new {{type}}(center - extents + 1, center + extents);
        }

        public {{areaType}}? To{{areaType}}()
        {
            if (Size == {{vectorIntType}}.Zero)
                return null;
            return {{areaType}}.FromMinAndMax(Min, Max - {{vectorIntType}}.One);
        }

        public {{areaFloatType}}? To{{areaFloatType}}()
        {
            if (Size == {{vectorIntType}}.Zero)
                return null;
            return {{areaFloatType}}.FromMinAndMax(Min.To{{vectorFloatType}}(), (Max - {{vectorIntType}}.One).To{{vectorFloatType}}());
        }

        public static bool operator ==({{type}} a, {{type}} b) => a.Min == b.Min && a.Max == b.Max;

        public static bool operator !=({{type}} a, {{type}} b) => a.Min != b.Min || a.Max != b.Max;

        public bool Contains({{vectorIntRealType}} point) => point >= Min && point < Max;

        public bool Overlaps({{type}} that)
        {
            if (Size == {{vectorIntType}}.Zero || that.Size == {{vectorIntType}}.Zero)
                return false;

            return Min < that.Max && that.Min < Max;
        }

        public {{type}} CombineWith({{type}} that)
        {
            if (Size == {{vectorIntType}}.Zero)
                return that;

            if (that.Size == {{vectorIntType}}.Zero)
                return this;

            var min = {{vectorIntType}}Utils.Min(Min, that.Min);
            var max = {{vectorIntType}}Utils.Max(Max, that.Max);
            return FromMinAndMax(min, max);
        }

        public {{type}} CombineWith({{vectorIntRealType}} point)
        {
            if (Contains(point))
                return this;

            var min = {{vectorIntType}}Utils.Min(Min, point);
            var max = {{vectorIntType}}Utils.Max(Max, point);

            return FromMinAndMax(min, max);
        }

        public {{type}} IntersectWith({{type}} that)
        {
            if (Size == {{vectorIntType}}.Zero || that.Size == {{vectorIntType}}.Zero)
                return Zero;

            var min = {{vectorIntType}}Utils.Max(Min, that.Min);
            var max = {{vectorIntType}}Utils.Max({{vectorIntType}}Utils.Min(Max, that.Max), min);

            return FromMinAndMax(min, max);
        }

        public {{type}} UnionWith({{type}}? that)
        {
            if (that == null)
                return this;
            return UnionWith(that.Value);
        }

        public {{type}} UnionWith({{type}} that)
        {
            if (Size == {{vectorIntType}}.Zero)
                return that;
            if (that.Size == {{vectorIntType}}.Zero)
                return this;

            var min = {{vectorIntType}}Utils.Min(Min, that.Min);
            var max = {{vectorIntType}}Utils.Max(Max, that.Max);

            return FromMinAndMax(min, max);
        }

        {{if dimSize < max_dim}}
        public {{area1MoreFloatType}} To{{area1MoreFloatType}}FromMinMax(float minZ, float maxZ) => {{area1MoreFloatType}}.FromMinAndMax(Min.To{{vector1MoreFloatType}}(minZ), Max.To{{vector1MoreFloatType}}(maxZ));
{{end}}
        public bool Equals({{type}} other) => this == other;

        public override bool Equals(object obj)
        {
            if (!(obj is {{type}}))
                return false;

            return Equals(({{type}}) obj);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                return Min.GetHashCode() + 7 * Max.GetHashCode();
            }
        }

        public override string ToString() => $"{{type}}: min={Min} max={Max} size={Size}";
    }
}