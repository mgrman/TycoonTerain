using System;
using Newtonsoft.Json;

namespace Votyra.Core.Models
{
    {{dimSize = dims.size}}
    {{type = "Area" +dimSize +"f"}}
    {{rangeType = "Range" +dimSize +"i"}}
    {{lineType = "Line" +dimSize +"f"}}
    {{vectorFloatType = "Vector" +dimSize +"f"}}
    {{vectorIntType = "Vector" +dimSize +"i"}}
    {{if dimSize != 1}}
        {{vectorFloatRealType=vectorFloatType}}
        {{vectorIntRealType=vectorIntType}}
    {{else}}
        {{vectorFloatRealType="float"}}
        {{vectorIntRealType="int"}}
    {{end}}
    {{func dimAccess}}{{if dimSize!=1}}{{$0}}.{{$1}}{{else}}{{$0}}{{end}}{{end}}
    public partial struct {{type}} : IEquatable<{{type}}>
    {
        public static readonly {{type}} Zero = new {{type}}({{vectorFloatType}}.Zero,{{vectorFloatType}}.Zero);
        public static readonly {{type}} All = new {{type}}({{vectorFloatType}}Utils.FromSame(float.MinValue / 2), {{vectorFloatType}}Utils.FromSame(float.MaxValue / 2));

        public readonly {{vectorFloatRealType}} Max;
        public readonly {{vectorFloatRealType}} Min;

        {{if dimSize==2}}
        public {{vectorFloatRealType}} X0Y0 => Min;
        public {{vectorFloatRealType}} X0Y1 => new {{vectorFloatType}}(Min.X,Max.Y);
        public {{vectorFloatRealType}} X1Y0 => new {{vectorFloatType}}(Max.X, Min.Y);
        public {{vectorFloatRealType}} X1Y1 => Max;

        public {{lineType}} X0 => new {{lineType}}(X0Y0, X0Y1);
        public {{lineType}} X1 => new {{lineType}}(X1Y0, X1Y1);
        public {{lineType}} Y0 => new {{lineType}}(X0Y0, X1Y0);
        public {{lineType}} Y1 => new {{lineType}}(X0Y1, X1Y1);

        {{end}}
        
        {{if dimSize>1}}
        {{for dim in dims}}
        public  Area1f {{dim}}=>Area1f.FromMinAndMax(Min.{{dim}},Max.{{dim}});
        {{end}}
        {{end}}

        [JsonConstructor]
        private {{type}}({{vectorFloatRealType}} min, {{vectorFloatRealType}} max)
        {
            Min = min;
            Max = max;
        }
        
[JsonIgnore]
        public {{vectorFloatRealType}} Center => (Max + Min) / 2f;
[JsonIgnore]
        public {{vectorFloatRealType}} Size => Max - Min;
[JsonIgnore]
        public {{vectorFloatRealType}} Extents => Size / 2;

        public float DiagonalLength => Size.Magnitude();
        
        public bool AnyNan => {{vectorFloatType}}Utils.AnyNan(Max) || {{vectorFloatType}}Utils.AnyNan(Min);

        public static {{type}} FromMinAndMax({{vectorFloatRealType}} min, {{vectorFloatRealType}} max) => new {{type}}(min, max);

        public static {{type}} FromMinAndSize({{vectorFloatRealType}} min, {{vectorFloatRealType}} size) => new {{type}}(min, min + size);

        public static {{type}} FromCenterAndSize({{vectorFloatRealType}} center, {{vectorFloatRealType}} size) => new {{type}}(center - size / 2, size);
      
        public static {{type}} FromCenterAndExtents({{vectorFloatRealType}} center, {{vectorFloatRealType}} extents)
        {
            if (extents.AnyNegative())
                throw new InvalidOperationException($"When creating {nameof({{type}})} from center '{center}' and extents '{extents}', extents cannot have a negative coordinate!");
            return new {{type}}(center - extents, center + extents);
        }

        public static bool operator ==({{type}} a, {{type}} b) => a.Center == b.Center && a.Size == b.Size;

        public static bool operator !=({{type}} a, {{type}} b) => a.Center != b.Center || a.Size != b.Size;

        public static {{type}} operator /({{type}} a, float b) => FromMinAndMax(a.Min / b, a.Max / b);

        {{if vectorFloatRealType!="float"}}
        public static {{type}} operator /({{type}} a, {{vectorFloatRealType}} b) => FromMinAndMax(a.Min / b, a.Max / b);
{{end}}
        public {{type}} IntersectWith({{type}} that)
        {
            if (Size == {{vectorFloatType}}.Zero || that.Size == {{vectorFloatType}}.Zero)
                return Zero;

            var min = {{vectorFloatType}}Utils.Max(Min, that.Min);
            var max = {{vectorFloatType}}Utils.Max({{vectorFloatType}}Utils.Min(Max, that.Max), min);

            return FromMinAndMax(min, max);
        }

        public {{type}} Encapsulate({{vectorFloatRealType}} point) => FromMinAndMax({{vectorFloatType}}Utils.Min(Min, point), {{vectorFloatType}}Utils.Max(Max, point));

        public {{type}} Encapsulate({{type}} bounds) => FromMinAndMax({{vectorFloatType}}Utils.Min(Min, bounds.Min), {{vectorFloatType}}Utils.Max(Max, bounds.Max));

        public bool Contains({{vectorFloatRealType}} point) => point >= Min && point <= Max;

        public {{rangeType}} RoundToInt() => {{rangeType}}.FromMinAndMax(Min.RoundTo{{vectorIntType}}(), Max.RoundTo{{vectorIntType}}());

        public {{rangeType}} RoundToContain() => {{rangeType}}.FromMinAndMax(Min.FloorTo{{vectorIntType}}(), Max.CeilTo{{vectorIntType}}());

        public {{type}} CombineWith({{type}} that)
        {
            if (Size == {{vectorFloatType}}.Zero)
                return that;

            if (that.Size == {{vectorFloatType}}.Zero)
                return this;

            var min = {{vectorFloatType}}Utils.Min(Min, that.Min);
            var max = {{vectorFloatType}}Utils.Max(Max, that.Max);
            return FromMinAndMax(min, max);
        }

        public {{type}} UnionWith({{type}} range) => {{type}}.FromMinAndMax({{vectorFloatType}}Utils.Min(Min, range.Min), {{vectorFloatType}}Utils.Min(Max, range.Max));

        public {{type}}? UnionWith({{type}}? range)
        {
            if (range == null)
                return this;

            return UnionWith(range.Value);
        }

        public {{type}} UnionWith({{vectorFloatRealType}} value)
        {
            if (value < Min)
                return {{type}}.FromMinAndMax(value, Max);
            if (value > Max)
                return {{type}}.FromMinAndMax(Min, value);
            return this;
        }


        public bool Equals({{type}} other) => this == other;

        public override bool Equals(object obj)
        {
            if (!(obj is {{type}}))
                return false;

            return Equals(({{type}}) obj);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                return Min.GetHashCode() + 7 * Max.GetHashCode();
            }
        }

        public override string ToString() => $"{{type}}: min={Min} max={Max} size={Size}";
    }
}